function P(){}function K(t,e){for(const n in e)t[n]=e[n];return t}function G(t){return t()}function z(){return Object.create(null)}function k(t){t.forEach(G)}function Q(t){return typeof t=="function"}function rt(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}function R(t){return Object.keys(t).length===0}function ct(t,e,n,s){if(t){const o=H(t,e,n,s);return t[0](o)}}function H(t,e,n,s){return t[1]&&s?K(n.ctx.slice(),t[1](s(e))):n.ctx}function it(t,e,n,s){if(t[2]&&s){const o=t[2](s(n));if(e.dirty===void 0)return o;if(typeof o=="object"){const a=[],r=Math.max(e.dirty.length,o.length);for(let u=0;u<r;u+=1)a[u]=e.dirty[u]|o[u];return a}return e.dirty|o}return e.dirty}function ft(t,e,n,s,o,a){if(o){const r=H(e,n,s,a);t.p(r,o)}}function ut(t){if(t.ctx.length>32){const e=[],n=t.ctx.length/32;for(let s=0;s<n;s++)e[s]=-1;return e}return-1}function at(t){const e={};for(const n in t)n[0]!=="$"&&(e[n]=t[n]);return e}function lt(t,e){const n={};e=new Set(e);for(const s in t)!e.has(s)&&s[0]!=="$"&&(n[s]=t[s]);return n}function dt(t,e){t.appendChild(e)}function _t(t,e,n){t.insertBefore(e,n||null)}function U(t){t.parentNode.removeChild(t)}function ht(t){return document.createElement(t)}function gt(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}function V(t){return document.createTextNode(t)}function mt(){return V(" ")}function yt(t,e,n,s){return t.addEventListener(e,n,s),()=>t.removeEventListener(e,n,s)}function W(t,e,n){n==null?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function pt(t,e){for(const n in e)W(t,n,e[n])}function X(t){return Array.from(t.childNodes)}function wt(t,e){e=""+e,t.wholeText!==e&&(t.data=e)}function xt(t,e){t.value=e==null?"":e}function kt(t,e,n){t.classList[n?"add":"remove"](e)}let B;function x(t){B=t}const w=[],D=[],E=[],F=[],Y=Promise.resolve();let L=!1;function Z(){L||(L=!0,Y.then(I))}function O(t){E.push(t)}const N=new Set;let v=0;function I(){const t=B;do{for(;v<w.length;){const e=w[v];v++,x(e),tt(e.$$)}for(x(null),w.length=0,v=0;D.length;)D.pop()();for(let e=0;e<E.length;e+=1){const n=E[e];N.has(n)||(N.add(n),n())}E.length=0}while(w.length);for(;F.length;)F.pop()();L=!1,N.clear(),x(t)}function tt(t){if(t.fragment!==null){t.update(),k(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(O)}}const S=new Set;let y;function $t(){y={r:0,c:[],p:y}}function bt(){y.r||k(y.c),y=y.p}function J(t,e){t&&t.i&&(S.delete(t),t.i(e))}function et(t,e,n,s){if(t&&t.o){if(S.has(t))return;S.add(t),y.c.push(()=>{S.delete(t),s&&(n&&t.d(1),s())}),t.o(e)}}function vt(t,e){et(t,1,1,()=>{e.delete(t.key)})}function Et(t,e,n,s,o,a,r,u,c,i,p,_){let l=t.length,h=a.length,d=l;const j={};for(;d--;)j[t[d].key]=d;const $=[],A=new Map,M=new Map;for(d=h;d--;){const f=_(o,a,d),g=n(f);let m=r.get(g);m?s&&m.p(f,e):(m=i(g,f),m.c()),A.set(g,$[d]=m),g in j&&M.set(g,Math.abs(d-j[g]))}const T=new Set,q=new Set;function C(f){J(f,1),f.m(u,p),r.set(f.key,f),p=f.first,h--}for(;l&&h;){const f=$[h-1],g=t[l-1],m=f.key,b=g.key;f===g?(p=f.first,l--,h--):A.has(b)?!r.has(m)||T.has(m)?C(f):q.has(b)?l--:M.get(m)>M.get(b)?(q.add(m),C(f)):(T.add(b),l--):(c(g,r),l--)}for(;l--;){const f=t[l];A.has(f.key)||c(f,r)}for(;h;)C($[h-1]);return $}function St(t,e){const n={},s={},o={$$scope:1};let a=t.length;for(;a--;){const r=t[a],u=e[a];if(u){for(const c in r)c in u||(s[c]=1);for(const c in u)o[c]||(n[c]=u[c],o[c]=1);t[a]=u}else for(const c in r)o[c]=1}for(const r in s)r in n||(n[r]=void 0);return n}function jt(t){t&&t.c()}function nt(t,e,n,s){const{fragment:o,on_mount:a,on_destroy:r,after_update:u}=t.$$;o&&o.m(e,n),s||O(()=>{const c=a.map(G).filter(Q);r?r.push(...c):k(c),t.$$.on_mount=[]}),u.forEach(O)}function st(t,e){const n=t.$$;n.fragment!==null&&(k(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function ot(t,e){t.$$.dirty[0]===-1&&(w.push(t),Z(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function At(t,e,n,s,o,a,r,u=[-1]){const c=B;x(t);const i=t.$$={fragment:null,ctx:null,props:a,update:P,not_equal:o,bound:z(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(c?c.$$.context:[])),callbacks:z(),dirty:u,skip_bound:!1,root:e.target||c.$$.root};r&&r(i.root);let p=!1;if(i.ctx=n?n(t,e.props||{},(_,l,...h)=>{const d=h.length?h[0]:l;return i.ctx&&o(i.ctx[_],i.ctx[_]=d)&&(!i.skip_bound&&i.bound[_]&&i.bound[_](d),p&&ot(t,_)),l}):[],i.update(),p=!0,k(i.before_update),i.fragment=s?s(i.ctx):!1,e.target){if(e.hydrate){const _=X(e.target);i.fragment&&i.fragment.l(_),_.forEach(U)}else i.fragment&&i.fragment.c();e.intro&&J(t.$$.fragment),nt(t,e.target,e.anchor,e.customElement),I()}x(c)}class Mt{$destroy(){st(this,1),this.$destroy=P}$on(e,n){const s=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return s.push(n),()=>{const o=s.indexOf(n);o!==-1&&s.splice(o,1)}}$set(e){this.$$set&&!R(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}export{ft as A,ut as B,it as C,St as D,lt as E,at as F,Mt as S,mt as a,W as b,jt as c,_t as d,ht as e,dt as f,wt as g,et as h,At as i,bt as j,J as k,U as l,nt as m,st as n,xt as o,yt as p,$t as q,vt as r,rt as s,V as t,Et as u,ct as v,K as w,gt as x,pt as y,kt as z};
