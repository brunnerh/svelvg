function P(){}function K(t,e){for(const n in e)t[n]=e[n];return t}function G(t){return t()}function z(){return Object.create(null)}function k(t){t.forEach(G)}function Q(t){return typeof t=="function"}function ot(t,e){return t!=t?e==e:t!==e}function R(t){return Object.keys(t).length===0}function ct(t,e,n,s){if(t){const r=H(t,e,n,s);return t[0](r)}}function H(t,e,n,s){return t[1]&&s?K(n.ctx.slice(),t[1](s(e))):n.ctx}function it(t,e,n,s){if(t[2]&&s){const r=t[2](s(n));if(e.dirty===void 0)return r;if(typeof r=="object"){const a=[],o=Math.max(e.dirty.length,r.length);for(let f=0;f<o;f+=1)a[f]=e.dirty[f]|r[f];return a}return e.dirty|r}return e.dirty}function ut(t,e,n,s,r,a){if(r){const o=H(e,n,s,a);t.p(o,r)}}function ft(t){if(t.ctx.length>32){const e=[],n=t.ctx.length/32;for(let s=0;s<n;s++)e[s]=-1;return e}return-1}function at(t){const e={};for(const n in t)n[0]!=="$"&&(e[n]=t[n]);return e}function lt(t,e){const n={};e=new Set(e);for(const s in t)!e.has(s)&&s[0]!=="$"&&(n[s]=t[s]);return n}function dt(t,e){t.appendChild(e)}function _t(t,e,n){t.insertBefore(e,n||null)}function U(t){t.parentNode.removeChild(t)}function ht(t){return document.createElement(t)}function gt(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}function V(t){return document.createTextNode(t)}function mt(){return V(" ")}function yt(t,e,n,s){return t.addEventListener(e,n,s),()=>t.removeEventListener(e,n,s)}function W(t,e,n){n==null?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function pt(t,e){for(const n in e)W(t,n,e[n])}function X(t){return Array.from(t.childNodes)}function wt(t,e){e=""+e,t.wholeText!==e&&(t.data=e)}function xt(t,e){t.value=e==null?"":e}function kt(t,e,n){t.classList[n?"add":"remove"](e)}let B;function x(t){B=t}const w=[],D=[],E=[],F=[],Y=Promise.resolve();let L=!1;function Z(){L||(L=!0,Y.then(I))}function O(t){E.push(t)}const N=new Set;let v=0;function I(){const t=B;do{for(;v<w.length;){const e=w[v];v++,x(e),tt(e.$$)}for(x(null),w.length=0,v=0;D.length;)D.pop()();for(let e=0;e<E.length;e+=1){const n=E[e];N.has(n)||(N.add(n),n())}E.length=0}while(w.length);for(;F.length;)F.pop()();L=!1,N.clear(),x(t)}function tt(t){if(t.fragment!==null){t.update(),k(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(O)}}const S=new Set;let y;function $t(){y={r:0,c:[],p:y}}function bt(){y.r||k(y.c),y=y.p}function J(t,e){t&&t.i&&(S.delete(t),t.i(e))}function et(t,e,n,s){if(t&&t.o){if(S.has(t))return;S.add(t),y.c.push(()=>{S.delete(t),s&&(n&&t.d(1),s())}),t.o(e)}}function vt(t,e){et(t,1,1,()=>{e.delete(t.key)})}function Et(t,e,n,s,r,a,o,f,c,i,p,_){let l=t.length,h=a.length,d=l;const j={};for(;d--;)j[t[d].key]=d;const $=[],A=new Map,M=new Map;for(d=h;d--;){const u=_(r,a,d),g=n(u);let m=o.get(g);m?s&&m.p(u,e):(m=i(g,u),m.c()),A.set(g,$[d]=m),g in j&&M.set(g,Math.abs(d-j[g]))}const T=new Set,q=new Set;function C(u){J(u,1),u.m(f,p),o.set(u.key,u),p=u.first,h--}for(;l&&h;){const u=$[h-1],g=t[l-1],m=u.key,b=g.key;u===g?(p=u.first,l--,h--):A.has(b)?!o.has(m)||T.has(m)?C(u):q.has(b)?l--:M.get(m)>M.get(b)?(q.add(m),C(u)):(T.add(b),l--):(c(g,o),l--)}for(;l--;){const u=t[l];A.has(u.key)||c(u,o)}for(;h;)C($[h-1]);return $}function St(t,e){const n={},s={},r={$$scope:1};let a=t.length;for(;a--;){const o=t[a],f=e[a];if(f){for(const c in o)c in f||(s[c]=1);for(const c in f)r[c]||(n[c]=f[c],r[c]=1);t[a]=f}else for(const c in o)r[c]=1}for(const o in s)o in n||(n[o]=void 0);return n}function jt(t){t&&t.c()}function nt(t,e,n,s){const{fragment:r,on_mount:a,on_destroy:o,after_update:f}=t.$$;r&&r.m(e,n),s||O(()=>{const c=a.map(G).filter(Q);o?o.push(...c):k(c),t.$$.on_mount=[]}),f.forEach(O)}function st(t,e){const n=t.$$;n.fragment!==null&&(k(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function rt(t,e){t.$$.dirty[0]===-1&&(w.push(t),Z(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function At(t,e,n,s,r,a,o,f=[-1]){const c=B;x(t);const i=t.$$={fragment:null,ctx:null,props:a,update:P,not_equal:r,bound:z(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(c?c.$$.context:[])),callbacks:z(),dirty:f,skip_bound:!1,root:e.target||c.$$.root};o&&o(i.root);let p=!1;if(i.ctx=n?n(t,e.props||{},(_,l,...h)=>{const d=h.length?h[0]:l;return i.ctx&&r(i.ctx[_],i.ctx[_]=d)&&(!i.skip_bound&&i.bound[_]&&i.bound[_](d),p&&rt(t,_)),l}):[],i.update(),p=!0,k(i.before_update),i.fragment=s?s(i.ctx):!1,e.target){if(e.hydrate){const _=X(e.target);i.fragment&&i.fragment.l(_),_.forEach(U)}else i.fragment&&i.fragment.c();e.intro&&J(t.$$.fragment),nt(t,e.target,e.anchor,e.customElement),I()}x(c)}class Mt{$destroy(){st(this,1),this.$destroy=P}$on(e,n){const s=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return s.push(n),()=>{const r=s.indexOf(n);r!==-1&&s.splice(r,1)}}$set(e){this.$$set&&!R(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}export{ut as A,ft as B,it as C,St as D,lt as E,at as F,Mt as S,W as a,_t as b,jt as c,dt as d,ht as e,wt as f,et as g,bt as h,At as i,J as j,U as k,st as l,nt as m,ot as n,xt as o,yt as p,$t as q,vt as r,mt as s,V as t,Et as u,ct as v,K as w,gt as x,pt as y,kt as z};
